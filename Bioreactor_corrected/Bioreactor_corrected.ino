/*
   Пример вывода на дисплей с регистром TM1637
   показывает все возможности библиотеки GyverTM1637
   AlexGyver Technologies http://alexgyver.ru/
*/

#define CLK 2
#define DIO 3

#include "GyverTM1637.h"
GyverTM1637 disp(CLK, DIO);

uint32_t Now, clocktimer;
boolean flag;

/*
   Пример работы релейного регулятора в автоматическом режиме по встроенному таймеру
   Давайте представим, что на 3 пине у нас спираль нагрева, подключенная через реле
   И есть какой то абстрактный датчик температуры, на который влияет спираль
*/

#include "GyverRelay.h"

// установка, гистерезис, направление регулирования
GyverRelay regulator(REVERSE);
// либо GyverRelay regulator(); без указания направления (будет REVERSE)

//===============================================================================
//  Константы
//===============================================================================
// Связанные с термистором:

/* Здесь у нас несколько констант, которые упрощают редактирование кода.
   Пройдемся по ним.

   Чтение из АЦП может дать одно значение при одной выборке, а затем немного
   отличающееся значение при следующей выборке. Чтобы избежать влияния шумов,
   мы можем считывать значения с вывода АЦП несколько раз, а затем усреднять
   значения, чтобы получить более постоянное значение. Эта константа используется
   в функции readThermistor. */
const int    SAMPLE_NUMBER      = 10;

/* Чтобы использовать бета уравнение, мы должны знать номинал второго резистора
   в нашем делителе. Если вы используете резистор с большим допуском, например,
   5% или даже 1%, измерьте его и поместите результат в омах сюда. */
const double BALANCE_RESISTOR   = 10000;

// Это помогает вычислять сопротивление термистора (подробности смотрите в статье).
const double MAX_ADC            = 1023.0;

/* Эта константа зависит от термистора и должна быть в техническом описании, или
   смотрите статью, как рассчитать ее, используя бета-уравнение. */
const double BETA               = 4150.0;

/* Необходима для уравнения преобразования в качестве "типовой" комнатной
   температуры. */
const double ROOM_TEMP          = 298.15;   // комнатная температура в Кельвинах

/* Термисторы обладают типовым сопротивлением при комнатной температуре,
   укажем его здесь. Опять же, необходимо для уравнения преобразования. */
const double RESISTOR_ROOM_TEMP = 22000.0;

//===============================================================================
//  Переменные
//===============================================================================
// Здесь мы будем хранить текущую температуру
double currentTemperature = 0;

//===============================================================================
//  Объявления выводов
//===============================================================================
// Входы:
int thermistorPins[] = {A0, A1, A2, A3};  // Входы АЦП, выходы делителей напряжения

void setup() {
  Serial.begin(9600);
  disp.clear();
  disp.brightness(7);  // яркость, 0 - 7 (минимум - максимум)
  //termistors
  pinMode(A0,INPUT);
  pinMode(A1,INPUT);
  pinMode(A2,INPUT);
  pinMode(A3,INPUT);
  //relay
  pinMode(4, OUTPUT);         // пин реле
  regulator.setpoint = 30;    // установка (ставим на 40 градусов)
  regulator.hysteresis = 5;   // ширина гистерезиса
  regulator.k = 0.5;          // коэффициент обратной связи (подбирается по факту)
  runningText();
}


void loop() {
  double currentTemp = readThermistor();
  ints(currentTemperature);
  
  regulator.input = currentTemp;   // сообщаем регулятору текущую температуру

  // getResult возвращает значение для управляющего устройства
  digitalWrite(4, regulator.getResult());  // отправляем на реле (ОС работает по своему таймеру)
}

//===============================================================================
//  Функции
//===============================================================================
/////////////////////////////
////// readThermistor ///////
/////////////////////////////
/*
Эта функция считывает значения с аналогового вывода, как показано ниже.
Преобразует входное напряжение в цифровое представление с помощью аналого-цифрового
преобразования. Однако, это выполняется несколько раз, чтобы мы могли
усреднить значение, чтобы избежать ошибок измерения.
Это усредненное значение затем используется для расчета сопротивления термистора.
После этого сопротивление используется для расчета температуры термистора.
Наконец, температура преобразуется в градусы Цельсия. 
*/

double readThermistor() 
{
  // переменные
  double rThermistor = 0;            // Хранит значение сопротивления термистора
  double tKelvin     = 0;            // Хранит рассчитанную температуру
  double tCelsius    = 0;            // Хранит температуру в градусах Цельсия
  double adcAverage  = 0;            // Хранит среднее значение напряжения
  int    adcSamples[SAMPLE_NUMBER];  // Массив для хранения отдельных результатов
                                     // измерений напряжения

  /* Рассчитать среднее сопротивление термистора:
     Как упоминалось выше, мы будем считывать значения АЦП несколько раз,
     чтобы получить массив выборок. Небольшая задержка используется для
     корректной работы функции analogRead. */
  double avg = 0;
  for (int c = 0; c < 5; c++)
  {
     for (int i = 0; i < SAMPLE_NUMBER; i++) 
     {
       adcSamples[i] = analogRead(thermistorPins[c]);  // прочитать значение на выводе и сохранить
       delay(10);        // ждем 10 миллисекунд
     }
    
     /* Затем мы просто усредняем все эти выборки для "сглаживания" измерений. */
     for (int i = 0; i < SAMPLE_NUMBER; i++) 
     {
       adcAverage += adcSamples[i];      // складываем все выборки . . .
     }
     adcAverage /= SAMPLE_NUMBER;        // . . . усредняем их с помощью деления
    
     /* Здесь мы рассчитываем сопротивление термистора, используя уравнение,
        описываемое в статье. */
     rThermistor = BALANCE_RESISTOR * ( (MAX_ADC / adcAverage) - 1);
    
     /* Здесь используется бета-уравнение, но оно отличается от того, что 
        описывалось в статье. Не беспокойтесь! Оно было перестроено, чтобы
        получить более "красивую" формулу. Попробуйте сами упростить уравнение,
        чтобы поупражняться в алгебре. Или просто используйте показанное здесь
        или то, что приведено в статье. В любом случае всё будет работать! */
     tKelvin = (BETA * ROOM_TEMP) / 
               (BETA + (ROOM_TEMP * log(rThermistor / RESISTOR_ROOM_TEMP)));
    
     /* Я буду использовать градусы Цельсия для отображения температуры.
        Я сделал это, чтобы увидеть типовую комнатную температуру, которая
        составляет 25 градусов Цельсия. */
     tCelsius = tKelvin - 273.15;  // преобразовать кельвины в цельсии
     avg += tCelsius;
  }
  avg = avg/5;
  return avg;    // вернуть температуру в градусах Цельсия
}

void ints(int num) {
  // тупо отправляем цифры
  disp.displayInt(num);
  delay(100);
}

void runningText() {
  byte welcome_banner[] = {_t, _u, _i, _t};
  disp.runningString(welcome_banner, sizeof(welcome_banner), 200);  // 200 это время в миллисекундах!
}
